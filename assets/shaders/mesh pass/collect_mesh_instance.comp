#version 450

#extension GL_GOOGLE_include_directive : require

#include "types.glsl"

layout (std430, binding = 0) writeonly buffer CountsBuffer {
    uint visible_mesh_instance_count;
    uint y;
    uint z;
    uint available_indirect_command_count;
};

layout (std430, binding = 1) writeonly buffer PrimitiveCountsBuffer {
    uint primitive_counts[];
};

layout (std430, binding = 2) readonly buffer MeshInstancePool {
    MeshInstance mesh_instances[];
};

layout (std430, binding = 3) writeonly buffer VisibleMeshInstanceIndices {
    uvec2 visible_mesh_instance_indices[];
};

layout (std430, binding = 4) readonly buffer MeshDescriptorBuffer {
    MeshDescriptor mesh_descriptors[];
};

layout (set = 1, binding = 0) uniform Camera {
    mat4 view;
    mat4 project;
    vec4 planes[6];
} camera;

// GPU Driven Pipeline: 1.遍历所有Mesh实例, 根据实例信息(位置, 旋转, 缩放), 判断是否在视锥内
// GPU Driven Pipeline: 2.根据实例信息, 判断Lod层级
// GPU Driven Pipeline: 3.将收集到的信息写入Buffer
layout (local_size_x = 64, local_size_y = 1, local_size_z = 1) in;
void main() {
    uint mesh_instance_index = gl_GlobalInvocationID.x;
    if (mesh_instance_index < mesh_instance_count) {
        MeshInstance mesh_instance = mesh_instances[mesh_instance_index];
        uint mesh_id = mesh_instance.mesh_id;

        // 视锥剔除
        vec4 location = camera.view * vec4(mesh_instance.location, 1);
        float radius = mesh_descriptors[mesh_id].radius * max(max(mesh_instance.scale.x, mesh_instance.scale.y), mesh_instance.scale.z);
        for (int i = 0; i < 6; i ++) {
            if ((camera.planes[i].x * location.x + camera.planes[i].y * location.y + camera.planes[i].z * location.z + camera.planes[i].w) <= -radius) {
                return;
            }
        }

        // 根据球包围体的投影面积选择Lod
        float k = radius / length(location);
        uint lod_index;
        if (k > 0.1) {
            lod_index = 0;
        } else if (k > 0.05) {
            lod_index = 1;
        } else if (k > 0.035) {
            lod_index = 2;
        } else if (k > 0.02) {
            lod_index = 3;
        } else if (k > 0.01) {
            lod_index = 4;
        } else {
            lod_index = 5;
        }
        lod_index = min(lod_index, mesh_descriptors[mesh_id].lod_count - 1);

        // 写入缓存
        uint new_mesh_instance_index = atomicAdd(visible_mesh_instance_count, 1);
        visible_mesh_instance_indices[new_mesh_instance_index] = uvec2(mesh_instance_index, lod_index);
        atomicAdd(primitive_counts[mesh_descriptors[mesh_id].lods[lod_index]], 1);
    }
}
