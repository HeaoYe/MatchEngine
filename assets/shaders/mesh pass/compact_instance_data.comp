#version 450

#extension GL_GOOGLE_include_directive : require

#include "types.glsl"

layout (std430, binding = 0) readonly buffer CountsBuffer {
    uint visible_mesh_instance_count_div_64;
    uint y;
    uint z;
    uint visible_mesh_instance_count;
    uint available_indirect_command_count;
};

layout (std430, binding = 2) readonly buffer MeshInstancePool {
    MeshInstance mesh_instances[];
};

layout (std430, binding = 3) readonly buffer VisibleMeshInstanceIndices {
    uvec2 visible_mesh_instance_indices[];
};

layout (std430, binding = 4) readonly buffer MeshDescriptorBuffer {
    MeshDescriptor mesh_descriptors[];
};

layout (std430, binding = 6) buffer IndirectCommandsBuffer {
    VkDrawIndexedIndirectCommand indirect_commands[];
};

layout (std430, binding = 8) writeonly buffer InstanceLocations {
    vec4 instance_locations[];
};

layout (std430, binding = 9) writeonly buffer InstanceRotation {
    vec4 instance_rotations[];
};

layout (std430, binding = 10) writeonly buffer InstanceScale {
    vec4 instance_scales[];
};

// GPU Driven Pipeline: 5.将所有可见的MeshInstance按照顺序, 将实例信息(位置, 旋转, 缩放)写入对应的顶点缓存
layout (local_size_x = 64, local_size_y = 1, local_size_z = 1) in;
void main() {
    uint mesh_instance_index = gl_GlobalInvocationID.x;
    if (mesh_instance_index < visible_mesh_instance_count) {
        uvec2 instance_info = visible_mesh_instance_indices[mesh_instance_index];
        MeshInstance mesh_instance = mesh_instances[instance_info.x];
        uint mesh_id = mesh_instance.mesh_id;
        uint primitive_index = mesh_descriptors[mesh_id].lods[instance_info.y];
        uint offset = indirect_commands[primitive_index].first_instance + atomicAdd(indirect_commands[primitive_index].instance_count, 1);
        instance_locations[offset] = vec4(mesh_instance.location, 0);
        instance_rotations[offset] = vec4(mesh_instance.rotation, 0);
        instance_scales[offset] = vec4(mesh_instance.scale, 0);
    }
}
